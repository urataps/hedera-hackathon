/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../../../common";

export type AdditionalSecurityDataStruct = {
  countriesControlListType: PromiseOrValue<boolean>;
  listOfCountries: PromiseOrValue<string>;
  info: PromiseOrValue<string>;
};

export type AdditionalSecurityDataStructOutput = [boolean, string, string] & {
  countriesControlListType: boolean;
  listOfCountries: string;
  info: string;
};

export type FactoryRegulationDataStruct = {
  regulationType: PromiseOrValue<BigNumberish>;
  regulationSubType: PromiseOrValue<BigNumberish>;
  additionalSecurityData: AdditionalSecurityDataStruct;
};

export type FactoryRegulationDataStructOutput = [
  number,
  number,
  AdditionalSecurityDataStructOutput
] & {
  regulationType: number;
  regulationSubType: number;
  additionalSecurityData: AdditionalSecurityDataStructOutput;
};

export type RegulationDataStruct = {
  regulationType: PromiseOrValue<BigNumberish>;
  regulationSubType: PromiseOrValue<BigNumberish>;
  dealSize: PromiseOrValue<BigNumberish>;
  accreditedInvestors: PromiseOrValue<BigNumberish>;
  maxNonAccreditedInvestors: PromiseOrValue<BigNumberish>;
  manualInvestorVerification: PromiseOrValue<BigNumberish>;
  internationalInvestors: PromiseOrValue<BigNumberish>;
  resaleHoldPeriod: PromiseOrValue<BigNumberish>;
};

export type RegulationDataStructOutput = [
  number,
  number,
  BigNumber,
  number,
  BigNumber,
  number,
  number,
  number
] & {
  regulationType: number;
  regulationSubType: number;
  dealSize: BigNumber;
  accreditedInvestors: number;
  maxNonAccreditedInvestors: BigNumber;
  manualInvestorVerification: number;
  internationalInvestors: number;
  resaleHoldPeriod: number;
};

export declare namespace TRexIFactory {
  export type ResolverProxyConfigurationStruct = {
    key: PromiseOrValue<BytesLike>;
    version: PromiseOrValue<BigNumberish>;
  };

  export type ResolverProxyConfigurationStructOutput = [string, BigNumber] & {
    key: string;
    version: BigNumber;
  };

  export type SecurityDataStruct = {
    arePartitionsProtected: PromiseOrValue<boolean>;
    isMultiPartition: PromiseOrValue<boolean>;
    resolver: PromiseOrValue<string>;
    resolverProxyConfiguration: TRexIFactory.ResolverProxyConfigurationStruct;
    rbacs: TRexIResolverProxy.RbacStruct[];
    isControllable: PromiseOrValue<boolean>;
    isWhiteList: PromiseOrValue<boolean>;
    maxSupply: PromiseOrValue<BigNumberish>;
    erc20MetadataInfo: TRexIERC20.ERC20MetadataInfoStruct;
    clearingActive: PromiseOrValue<boolean>;
    internalKycActivated: PromiseOrValue<boolean>;
    externalPauses: PromiseOrValue<string>[];
    externalControlLists: PromiseOrValue<string>[];
    externalKycLists: PromiseOrValue<string>[];
    erc20VotesActivated: PromiseOrValue<boolean>;
    compliance: PromiseOrValue<string>;
    identityRegistry: PromiseOrValue<string>;
  };

  export type SecurityDataStructOutput = [
    boolean,
    boolean,
    string,
    TRexIFactory.ResolverProxyConfigurationStructOutput,
    TRexIResolverProxy.RbacStructOutput[],
    boolean,
    boolean,
    BigNumber,
    TRexIERC20.ERC20MetadataInfoStructOutput,
    boolean,
    boolean,
    string[],
    string[],
    string[],
    boolean,
    string,
    string
  ] & {
    arePartitionsProtected: boolean;
    isMultiPartition: boolean;
    resolver: string;
    resolverProxyConfiguration: TRexIFactory.ResolverProxyConfigurationStructOutput;
    rbacs: TRexIResolverProxy.RbacStructOutput[];
    isControllable: boolean;
    isWhiteList: boolean;
    maxSupply: BigNumber;
    erc20MetadataInfo: TRexIERC20.ERC20MetadataInfoStructOutput;
    clearingActive: boolean;
    internalKycActivated: boolean;
    externalPauses: string[];
    externalControlLists: string[];
    externalKycLists: string[];
    erc20VotesActivated: boolean;
    compliance: string;
    identityRegistry: string;
  };

  export type BondDataStruct = {
    security: TRexIFactory.SecurityDataStruct;
    bondDetails: TRexIBondRead.BondDetailsDataStruct;
    couponDetails: TRexIBondRead.CouponDetailsDataStruct;
  };

  export type BondDataStructOutput = [
    TRexIFactory.SecurityDataStructOutput,
    TRexIBondRead.BondDetailsDataStructOutput,
    TRexIBondRead.CouponDetailsDataStructOutput
  ] & {
    security: TRexIFactory.SecurityDataStructOutput;
    bondDetails: TRexIBondRead.BondDetailsDataStructOutput;
    couponDetails: TRexIBondRead.CouponDetailsDataStructOutput;
  };

  export type EquityDataStruct = {
    security: TRexIFactory.SecurityDataStruct;
    equityDetails: TRexIEquity.EquityDetailsDataStruct;
  };

  export type EquityDataStructOutput = [
    TRexIFactory.SecurityDataStructOutput,
    TRexIEquity.EquityDetailsDataStructOutput
  ] & {
    security: TRexIFactory.SecurityDataStructOutput;
    equityDetails: TRexIEquity.EquityDetailsDataStructOutput;
  };
}

export declare namespace TRexIResolverProxy {
  export type RbacStruct = {
    role: PromiseOrValue<BytesLike>;
    members: PromiseOrValue<string>[];
  };

  export type RbacStructOutput = [string, string[]] & {
    role: string;
    members: string[];
  };
}

export declare namespace TRexIERC20 {
  export type ERC20MetadataInfoStruct = {
    name: PromiseOrValue<string>;
    symbol: PromiseOrValue<string>;
    isin: PromiseOrValue<string>;
    decimals: PromiseOrValue<BigNumberish>;
  };

  export type ERC20MetadataInfoStructOutput = [
    string,
    string,
    string,
    number
  ] & { name: string; symbol: string; isin: string; decimals: number };
}

export declare namespace TRexIBondRead {
  export type BondDetailsDataStruct = {
    currency: PromiseOrValue<BytesLike>;
    nominalValue: PromiseOrValue<BigNumberish>;
    startingDate: PromiseOrValue<BigNumberish>;
    maturityDate: PromiseOrValue<BigNumberish>;
  };

  export type BondDetailsDataStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    currency: string;
    nominalValue: BigNumber;
    startingDate: BigNumber;
    maturityDate: BigNumber;
  };

  export type CouponDetailsDataStruct = {
    couponFrequency: PromiseOrValue<BigNumberish>;
    couponRate: PromiseOrValue<BigNumberish>;
    firstCouponDate: PromiseOrValue<BigNumberish>;
  };

  export type CouponDetailsDataStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    couponFrequency: BigNumber;
    couponRate: BigNumber;
    firstCouponDate: BigNumber;
  };
}

export declare namespace TRexIEquity {
  export type EquityDetailsDataStruct = {
    votingRight: PromiseOrValue<boolean>;
    informationRight: PromiseOrValue<boolean>;
    liquidationRight: PromiseOrValue<boolean>;
    subscriptionRight: PromiseOrValue<boolean>;
    conversionRight: PromiseOrValue<boolean>;
    redemptionRight: PromiseOrValue<boolean>;
    putRight: PromiseOrValue<boolean>;
    dividendRight: PromiseOrValue<BigNumberish>;
    currency: PromiseOrValue<BytesLike>;
    nominalValue: PromiseOrValue<BigNumberish>;
  };

  export type EquityDetailsDataStructOutput = [
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    number,
    string,
    BigNumber
  ] & {
    votingRight: boolean;
    informationRight: boolean;
    liquidationRight: boolean;
    subscriptionRight: boolean;
    conversionRight: boolean;
    redemptionRight: boolean;
    putRight: boolean;
    dividendRight: number;
    currency: string;
    nominalValue: BigNumber;
  };
}

export interface TRexIFactoryInterface extends utils.Interface {
  functions: {
    "deployBond(((bool,bool,address,(bytes32,uint256),(bytes32,address[])[],bool,bool,uint256,(string,string,string,uint8),bool,bool,address[],address[],address[],bool,address,address),(bytes3,uint256,uint256,uint256),(uint256,uint256,uint256)),(uint8,uint8,(bool,string,string)))": FunctionFragment;
    "deployEquity(((bool,bool,address,(bytes32,uint256),(bytes32,address[])[],bool,bool,uint256,(string,string,string,uint8),bool,bool,address[],address[],address[],bool,address,address),(bool,bool,bool,bool,bool,bool,bool,uint8,bytes3,uint256)),(uint8,uint8,(bool,string,string)))": FunctionFragment;
    "getAppliedRegulationData(uint8,uint8)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "deployBond"
      | "deployEquity"
      | "getAppliedRegulationData"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "deployBond",
    values: [TRexIFactory.BondDataStruct, FactoryRegulationDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "deployEquity",
    values: [TRexIFactory.EquityDataStruct, FactoryRegulationDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getAppliedRegulationData",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "deployBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deployEquity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAppliedRegulationData",
    data: BytesLike
  ): Result;

  events: {
    "BondDeployed(address,address,tuple,tuple)": EventFragment;
    "EquityDeployed(address,address,tuple,tuple)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BondDeployed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EquityDeployed"): EventFragment;
}

export interface BondDeployedEventObject {
  deployer: string;
  bondAddress: string;
  bondData: TRexIFactory.BondDataStructOutput;
  regulationData: FactoryRegulationDataStructOutput;
}
export type BondDeployedEvent = TypedEvent<
  [
    string,
    string,
    TRexIFactory.BondDataStructOutput,
    FactoryRegulationDataStructOutput
  ],
  BondDeployedEventObject
>;

export type BondDeployedEventFilter = TypedEventFilter<BondDeployedEvent>;

export interface EquityDeployedEventObject {
  deployer: string;
  equityAddress: string;
  equityData: TRexIFactory.EquityDataStructOutput;
  regulationData: FactoryRegulationDataStructOutput;
}
export type EquityDeployedEvent = TypedEvent<
  [
    string,
    string,
    TRexIFactory.EquityDataStructOutput,
    FactoryRegulationDataStructOutput
  ],
  EquityDeployedEventObject
>;

export type EquityDeployedEventFilter = TypedEventFilter<EquityDeployedEvent>;

export interface TRexIFactory extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TRexIFactoryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    deployBond(
      _bondData: TRexIFactory.BondDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deployEquity(
      _equityData: TRexIFactory.EquityDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAppliedRegulationData(
      _regulationType: PromiseOrValue<BigNumberish>,
      _regulationSubType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [RegulationDataStructOutput] & {
        regulationData_: RegulationDataStructOutput;
      }
    >;
  };

  deployBond(
    _bondData: TRexIFactory.BondDataStruct,
    _factoryRegulationData: FactoryRegulationDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deployEquity(
    _equityData: TRexIFactory.EquityDataStruct,
    _factoryRegulationData: FactoryRegulationDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAppliedRegulationData(
    _regulationType: PromiseOrValue<BigNumberish>,
    _regulationSubType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<RegulationDataStructOutput>;

  callStatic: {
    deployBond(
      _bondData: TRexIFactory.BondDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    deployEquity(
      _equityData: TRexIFactory.EquityDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    getAppliedRegulationData(
      _regulationType: PromiseOrValue<BigNumberish>,
      _regulationSubType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<RegulationDataStructOutput>;
  };

  filters: {
    "BondDeployed(address,address,tuple,tuple)"(
      deployer?: PromiseOrValue<string> | null,
      bondAddress?: null,
      bondData?: null,
      regulationData?: null
    ): BondDeployedEventFilter;
    BondDeployed(
      deployer?: PromiseOrValue<string> | null,
      bondAddress?: null,
      bondData?: null,
      regulationData?: null
    ): BondDeployedEventFilter;

    "EquityDeployed(address,address,tuple,tuple)"(
      deployer?: PromiseOrValue<string> | null,
      equityAddress?: null,
      equityData?: null,
      regulationData?: null
    ): EquityDeployedEventFilter;
    EquityDeployed(
      deployer?: PromiseOrValue<string> | null,
      equityAddress?: null,
      equityData?: null,
      regulationData?: null
    ): EquityDeployedEventFilter;
  };

  estimateGas: {
    deployBond(
      _bondData: TRexIFactory.BondDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deployEquity(
      _equityData: TRexIFactory.EquityDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAppliedRegulationData(
      _regulationType: PromiseOrValue<BigNumberish>,
      _regulationSubType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    deployBond(
      _bondData: TRexIFactory.BondDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deployEquity(
      _equityData: TRexIFactory.EquityDataStruct,
      _factoryRegulationData: FactoryRegulationDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAppliedRegulationData(
      _regulationType: PromiseOrValue<BigNumberish>,
      _regulationSubType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
